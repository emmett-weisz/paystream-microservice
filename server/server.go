package server

import (
	"context"
	"log"
	"net"

	kafkago "github.com/segmentio/kafka-go"

	"github.com/emmett-weisz/paystream-microservice/kafka"
	paymentpb "github.com/emmett-weisz/paystream-microservice/proto/paymentpb"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

// This is where the server implements the PaymentVerifierServer interface generated by protobuf.
type server struct {
	paymentpb.UnimplementedPaymentVerifierServer
	kafkaWriter *kafkago.Writer
}

func NewServer(kafkaWriter *kafkago.Writer) *server {
	return &server{kafkaWriter: kafkaWriter}
}

// VerifyPayment handles incoming VerifyPayment gRPC calls.
func (s *server) VerifyPayment(ctx context.Context, req *paymentpb.PaymentRequest) (*paymentpb.PaymentResponse, error) {
	log.Printf("Received VerifyPayment request: payer_id=%s, amount=%f %s, method=%s",
		req.PayerId, req.Amount, req.Currency, req.PaymentMethod)

	// Send payment message to Kafka
	err := kafka.SendPaymentMessage(s.kafkaWriter, kafka.PaymentMessage{
		PayerID:       req.PayerId,
		Amount:        req.Amount,
		Currency:      req.Currency,
		PaymentMethod: req.PaymentMethod,
	})

	if err != nil {
		log.Printf("Kafka error: %v", err)
		return &paymentpb.PaymentResponse{
			Status:  "error",
			Message: "Failed to publish message",
		}, err
	}

	return &paymentpb.PaymentResponse{
		Status:  "success",
		Message: "Payment verified and message published",
	}, nil
}

// RunGRPCServer starts the gRPC server on the specified port.
func RunGRPCServer(port string, kafkaWriter *kafkago.Writer) error {
	lis, err := net.Listen("tcp", ":"+port)
	if err != nil {
		return err
	}

	grpcServer := grpc.NewServer()
	paymentpb.RegisterPaymentVerifierServer(grpcServer, NewServer(kafkaWriter))

	reflection.Register(grpcServer)

	log.Printf("gRPC server listening on port %s", port)
	return grpcServer.Serve(lis)
}
